/**
 * @claude-flow/codex - config.toml Generator
 *
 * Generates Codex CLI configuration files in TOML format
 */

import type { ConfigTomlOptions, McpServerConfig, SkillConfig, ConfigProfile } from '../types.js';

/**
 * Security configuration options
 */
interface SecurityConfig {
  inputValidation?: boolean;
  pathTraversal?: boolean;
  secretScanning?: boolean;
  cveScanning?: boolean;
  maxFileSize?: number;
  allowedExtensions?: string[];
  blockedPatterns?: string[];
}

/**
 * Performance configuration options
 */
interface PerformanceConfig {
  maxAgents?: number;
  taskTimeout?: number;
  memoryLimit?: string;
  cacheEnabled?: boolean;
  cacheTtl?: number;
  parallelExecution?: boolean;
}

/**
 * Logging configuration options
 */
interface LoggingConfig {
  level?: 'debug' | 'info' | 'warn' | 'error';
  format?: 'json' | 'text' | 'pretty';
  destination?: 'stdout' | 'file' | 'both';
  filePath?: string;
  maxFiles?: number;
  maxSize?: string;
}

/**
 * Extended configuration options
 */
interface ExtendedConfigTomlOptions extends ConfigTomlOptions {
  security?: SecurityConfig;
  performance?: PerformanceConfig;
  logging?: LoggingConfig;
}

/**
 * Generate a config.toml file based on the provided options
 */
export async function generateConfigToml(options: ExtendedConfigTomlOptions = {}): Promise<string> {
  const {
    model = 'gpt-5.3-codex',
    approvalPolicy = 'on-request',
    sandboxMode = 'workspace-write',
    webSearch = 'cached',
    projectDocMaxBytes = 65536,
    features = {},
    mcpServers = [],
    skills = [],
    profiles = {},
    historyPersistence = 'save-all',
    security = {},
    performance = {},
    logging = {},
  } = options;

  const lines: string[] = [];

  // Header
  lines.push('# =============================================================================');
  lines.push('# Claude Flow V3 - Codex Configuration');
  lines.push('# =============================================================================');
  lines.push('# Generated by: @claude-flow/codex');
  lines.push('# Documentation: https://github.com/ruvnet/claude-flow');
  lines.push('# ');
  lines.push('# This file configures the Codex CLI for Claude Flow integration.');
  lines.push('# Place in .agents/config.toml (project) or .codex/config.toml (user).');
  lines.push('# =============================================================================');
  lines.push('');
  lines.push('# =============================================================================');
  lines.push('# Core Settings');
  lines.push('# =============================================================================');
  lines.push('');
  lines.push('# Model selection - the AI model to use for code generation');
  lines.push('# Options: gpt-5.3-codex, gpt-4o, claude-sonnet, claude-opus');
  lines.push(`model = "${model}"`);
  lines.push('');
  lines.push('# Approval policy determines when human approval is required');
  lines.push('# - untrusted: Always require approval');
  lines.push('# - on-failure: Require approval only after failures');
  lines.push('# - on-request: Require approval for significant changes');
  lines.push('# - never: Auto-approve all actions (use with caution)');
  lines.push(`approval_policy = "${approvalPolicy}"`);
  lines.push('');
  lines.push('# Sandbox mode controls file system access');
  lines.push('# - read-only: Can only read files, no modifications');
  lines.push('# - workspace-write: Can write within workspace directory');
  lines.push('# - danger-full-access: Full file system access (dangerous)');
  lines.push(`sandbox_mode = "${sandboxMode}"`);
  lines.push('');
  lines.push('# Web search enables internet access for research');
  lines.push('# - disabled: No web access');
  lines.push('# - cached: Use cached results when available');
  lines.push('# - live: Always fetch fresh results');
  lines.push(`web_search = "${webSearch}"`);
  lines.push('');

  // Project Documentation
  lines.push('# =============================================================================');
  lines.push('# Project Documentation');
  lines.push('# =============================================================================');
  lines.push('');
  lines.push('# Maximum bytes to read from AGENTS.md files');
  lines.push(`project_doc_max_bytes = ${projectDocMaxBytes}`);
  lines.push('');
  lines.push('# Fallback filenames if AGENTS.md not found');
  lines.push('project_doc_fallback_filenames = [');
  lines.push('  "AGENTS.md",');
  lines.push('  "TEAM_GUIDE.md",');
  lines.push('  ".agents.md"');
  lines.push(']');
  lines.push('');

  // Features
  lines.push('# =============================================================================');
  lines.push('# Features');
  lines.push('# =============================================================================');
  lines.push('');
  lines.push('[features]');
  lines.push('# Enable child AGENTS.md guidance');
  lines.push(`child_agents_md = ${features.childAgentsMd ?? true}`);
  lines.push('');
  lines.push('# Cache shell environment for faster repeated commands');
  lines.push(`shell_snapshot = ${features.shellSnapshot ?? true}`);
  lines.push('');
  lines.push('# Smart approvals based on request context');
  lines.push(`request_rule = ${features.requestRule ?? true}`);
  lines.push('');
  lines.push('# Enable remote compaction for large histories');
  lines.push(`remote_compaction = ${features.remoteCompaction ?? true}`);
  lines.push('');

  // MCP Servers
  if (mcpServers.length > 0 || true) { // Always include claude-flow by default
    lines.push('# =============================================================================');
    lines.push('# MCP Servers');
    lines.push('# =============================================================================');
    lines.push('');

    // Default claude-flow server
    const hasClaudeFlow = mcpServers.some(s => s.name === 'claude-flow');
    if (!hasClaudeFlow) {
      lines.push(...generateMcpServer({
        name: 'claude-flow',
        command: 'npx',
        args: ['-y', '@claude-flow/cli@latest'],
        enabled: true,
        toolTimeout: 120,
      }));
      lines.push('');
    }

    for (const server of mcpServers) {
      lines.push(...generateMcpServer(server));
      lines.push('');
    }
  }

  // Skills Configuration
  if (skills.length > 0) {
    lines.push('# =============================================================================');
    lines.push('# Skills Configuration');
    lines.push('# =============================================================================');
    lines.push('');

    for (const skill of skills) {
      lines.push(...generateSkillConfig(skill));
      lines.push('');
    }
  }

  // Profiles
  lines.push('# =============================================================================');
  lines.push('# Profiles');
  lines.push('# =============================================================================');
  lines.push('');

  // Default profiles
  const defaultProfiles: Record<string, ConfigProfile> = {
    dev: {
      approvalPolicy: 'never',
      sandboxMode: 'danger-full-access',
      webSearch: 'live',
    },
    safe: {
      approvalPolicy: 'untrusted',
      sandboxMode: 'read-only',
      webSearch: 'disabled',
    },
    ci: {
      approvalPolicy: 'never',
      sandboxMode: 'workspace-write',
      webSearch: 'cached',
    },
    ...profiles,
  };

  for (const [name, profile] of Object.entries(defaultProfiles)) {
    lines.push(...generateProfile(name, profile));
    lines.push('');
  }

  // History
  lines.push('# =============================================================================');
  lines.push('# History');
  lines.push('# =============================================================================');
  lines.push('');
  lines.push('[history]');
  lines.push('# Save all session transcripts');
  lines.push(`persistence = "${historyPersistence}"`);
  lines.push('');

  // Shell Environment Policy
  lines.push('# =============================================================================');
  lines.push('# Shell Environment');
  lines.push('# =============================================================================');
  lines.push('');
  lines.push('[shell_environment_policy]');
  lines.push('# Inherit environment variables');
  lines.push('inherit = "core"');
  lines.push('');
  lines.push('# Exclude sensitive variables');
  lines.push('exclude = ["*_KEY", "*_SECRET", "*_TOKEN", "*_PASSWORD"]');
  lines.push('');

  // Sandbox Workspace Write Settings
  lines.push('# =============================================================================');
  lines.push('# Sandbox Workspace Write Settings');
  lines.push('# =============================================================================');
  lines.push('');
  lines.push('[sandbox_workspace_write]');
  lines.push('# Additional writable paths beyond workspace');
  lines.push('writable_roots = []');
  lines.push('');
  lines.push('# Allow network access');
  lines.push('network_access = true');
  lines.push('');
  lines.push('# Exclude temp directories');
  lines.push('exclude_slash_tmp = false');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate MCP server configuration lines
 */
function generateMcpServer(server: McpServerConfig): string[] {
  const lines: string[] = [];
  lines.push(`[mcp_servers.${server.name}]`);
  lines.push(`command = "${server.command}"`);

  if (server.args && server.args.length > 0) {
    const argsStr = server.args.map(a => `"${a}"`).join(', ');
    lines.push(`args = [${argsStr}]`);
  }

  lines.push(`enabled = ${server.enabled ?? true}`);

  if (server.toolTimeout) {
    lines.push(`tool_timeout_sec = ${server.toolTimeout}`);
  }

  if (server.env && Object.keys(server.env).length > 0) {
    lines.push('');
    lines.push(`[mcp_servers.${server.name}.env]`);
    for (const [key, value] of Object.entries(server.env)) {
      lines.push(`${key} = "${value}"`);
    }
  }

  return lines;
}

/**
 * Generate skill configuration lines
 */
function generateSkillConfig(skill: SkillConfig): string[] {
  const lines: string[] = [];
  lines.push('[[skills.config]]');
  lines.push(`path = "${skill.path}"`);
  lines.push(`enabled = ${skill.enabled ?? true}`);
  return lines;
}

/**
 * Generate profile configuration lines
 */
function generateProfile(name: string, profile: ConfigProfile): string[] {
  const lines: string[] = [];
  const comment = name === 'dev' ? 'Development profile - more permissive for local work'
    : name === 'safe' ? 'Safe profile - maximum restrictions'
    : name === 'ci' ? 'CI profile - for automated pipelines'
    : `${name} profile`;

  lines.push(`# ${comment}`);
  lines.push(`[profiles.${name}]`);

  if (profile.approvalPolicy) {
    lines.push(`approval_policy = "${profile.approvalPolicy}"`);
  }
  if (profile.sandboxMode) {
    lines.push(`sandbox_mode = "${profile.sandboxMode}"`);
  }
  if (profile.webSearch) {
    lines.push(`web_search = "${profile.webSearch}"`);
  }

  return lines;
}

/**
 * Generate minimal config.toml
 */
export async function generateMinimalConfigToml(options: ConfigTomlOptions = {}): Promise<string> {
  const {
    model = 'gpt-5.3-codex',
    approvalPolicy = 'on-request',
    sandboxMode = 'workspace-write',
  } = options;

  return `# Claude Flow V3 - Minimal Codex Configuration

model = "${model}"
approval_policy = "${approvalPolicy}"
sandbox_mode = "${sandboxMode}"

[mcp_servers.claude-flow]
command = "npx"
args = ["-y", "@claude-flow/cli@latest"]
enabled = true
`;
}

/**
 * Generate CI/CD config.toml
 */
export async function generateCIConfigToml(): Promise<string> {
  return `# Claude Flow V3 - CI/CD Pipeline Configuration

model = "gpt-5.3-codex"
approval_policy = "never"
sandbox_mode = "workspace-write"
web_search = "disabled"

[features]
shell_snapshot = false
remote_compaction = false

[mcp_servers.claude-flow]
command = "npx"
args = ["-y", "@claude-flow/cli@latest"]
enabled = true

[history]
persistence = "none"
`;
}
